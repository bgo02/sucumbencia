<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Calculadora de Sucumbência Previdenciária</title>
<style>
:root{--bg:#f4f6fb;--card:#fff;--muted:#556;--accent:#0f62fe}
body{font-family:Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; background:var(--bg); margin:0; color:#0b1220}
.wrap{max-width:980px;margin:28px auto;padding:20px}
header{display:flex;align-items:center;gap:12px}
header h1{font-size:18px;margin:0}
.grid{display:grid;grid-template-columns:1fr 420px;gap:18px;margin-top:18px}
@media(max-width:920px){.grid{grid-template-columns:1fr}}
.card{background:var(--card);border-radius:12px;padding:16px;box-shadow:0 6px 18px rgba(11,18,32,0.06)}
label{display:block;font-size:13px;color:var(--muted);margin-bottom:6px}
textarea,input,select{width:100%;padding:10px;border-radius:8px;border:1px solid #e6e9ef;font-size:14px;box-sizing:border-box}
textarea{min-height:110px;resize:vertical}
.row{display:flex;gap:10px}
.col{flex:1}
.controls{display:flex;gap:10px;align-items:center;margin-top:12px}
button{background:var(--accent);color:#fff;padding:10px 12px;border-radius:8px;border:0;cursor:pointer}
button.secondary{background:#eef3ff;color:var(--accent);border:1px solid rgba(15,98,254,0.12)}
.result{white-space:pre-wrap;background:#0b122033;padding:12px;border-radius:8px;min-height:160px;font-family:ui-monospace,Menlo,monospace}
.meta{font-size:13px;color:var(--muted);margin-top:8px}
.footer{margin-top:16px;font-size:13px;color:var(--muted)}
.small{font-size:12px;color:var(--muted);margin-top:6px}
</style>
</head>
<body>
<div class="wrap">
  <header>
    <svg width="40" height="40" viewBox="0 0 24 24" fill="none"><rect x="2" y="2" width="20" height="20" rx="4" fill="#0f62fe"/><path d="M7 9h10M7 13h6" stroke="#fff" stroke-width="1.6" stroke-linecap="round"/></svg>
    <h1>Calculadora de Sucumbência Previdenciária — Minuta Automática</h1>
  </header>

  <div class="grid">
    <div class="card" aria-live="polite">
      <label>Todos os períodos controvertidos (cole de qualquer jeito)</label>
      <textarea id="inputCont" placeholder="Cole planilha, PDF convertido ou texto livre com períodos (ex: 01/01/1990 a 31/12/1994; 01/03/1998 a 28/02/2001)"></textarea>

      <label>Períodos acolhidos (deferidos) — opcional</label>
      <textarea id="inputAcol" placeholder="Cole apenas os períodos reconhecidos a favor do autor"></textarea>

      <div class="row" style="margin-top:8px">
        <div class="col">
          <label>O benefício foi concedido?</label>
          <select id="selectBenef"><option value="sim">Sim</option><option value="nao">Não</option></select>
        </div>
        <div class="col">
          <label>Há pedido de danos morais?</label>
          <select id="selectDanos"><option value="nao" selected>Não</option><option value="sim">Sim</option></select>
        </div>
      </div>

      <div id="boxDanos" style="display:none;margin-top:10px">
        <div class="row">
          <div class="col">
            <label>Valor total da causa (R$)</label>
            <input id="valorCausa" placeholder="ex: 15000,00" />
          </div>
          <div class="col">
            <label>Valor pedido danos morais (R$)</label>
            <input id="valorDanos" placeholder="ex: 5000,00" />
          </div>
        </div>
      </div>

      <div class="row" style="margin-top:10px">
        <div class="col">
          <label>Autora possui AJG?</label>
          <select id="selectAJG"><option value="sim" selected>Sim</option><option value="nao">Não</option></select>
        </div>
        <div class="col">
          <label>Casas decimais (arredondamento)</label>
          <select id="selectCasas"><option value="1">1 casa</option><option value="2">2 casas</option></select>
        </div>
      </div>

      <div style="margin-top:10px">
        <label>Regra de sucumbência mínima (percentual):</label>
        <input id="minimoInput" type="number" step="0.01" value="10" />
        <div class="meta">Se o êxito ponderado da parte autora for inferior a este percentual (em %), aplica-se sucumbência mínima (a outra parte arcará integralmente com os honorários). Padrão: 10%.</div>
      </div>

      <div class="controls">
        <button id="btnProcess">Validar & Processar</button>
        <button id="btnCalc" class="secondary">Calcular e Gerar Minuta</button>
        <button id="btnCopy" class="secondary">Copiar Minuta</button>
        <button id="btnDownload" class="secondary">Baixar .txt</button>
      </div>

      <div class="small">Observação: meses = 30 dias; anos = 365 dias; datas inclusivas. O parser aceita dd/mm/aaaa, d/m/aa, . ou - como separadores e colagens de planilha.</div>
    </div>

    <div class="card">
      <label>Resumo do processamento</label>
      <div id="summary" class="result">Ainda não processado.</div>

      <label style="margin-top:12px">Minuta para colagem na sentença</label>
      <div id="minuta" class="result">Sem minuta.</div>
      <div id="detalhe" class="meta"></div>
    </div>
  </div>

  <div class="footer">Funciona 100% offline no navegador. Nenhuma chave ou API externa é necessária.</div>
</div>

<script>
/* ----------------------------
   Utilitários de data / parsing
   ---------------------------- */

function normalizeInput(s){
  if(!s) return '';
  return s.replace(/\u2013|\u2014/g,'-').replace(/\t/g,' ').replace(/\r/g,'\n').replace(/\u00A0/g,' ');
}

/* normalize date string to DD/MM/YYYY (handles dd/mm/yy) */
function normalizeDateStr(s){
  s = s.trim();
  s = s.replace(/\./g,'/').replace(/-/g,'/').replace(/\s+/g,'');
  const parts = s.split('/');
  if(parts.length !== 3) return s;
  let [d,m,y] = parts;
  d = d.padStart(2,'0');
  m = m.padStart(2,'0');
  if(y.length === 2){
    const yi = parseInt(y,10);
    y = (yi < 50 ? 2000+yi : 1900+yi).toString();
  }
  return `${d}/${m}/${y}`;
}

/* parse dd/mm/yyyy -> {d,m,y,abs} where abs uses rule y*365 + m*30 + d */
function parseDMY(s){
  const parts = s.split('/');
  if(parts.length !== 3) return null;
  const d = parseInt(parts[0],10), m = parseInt(parts[1],10), y = parseInt(parts[2],10);
  if(isNaN(d)||isNaN(m)||isNaN(y)) return null;
  if(d<1||d>31||m<1||m>12) return null;
  return {d,m,y,abs: y*365 + m*30 + d};
}

/* extract ranges like dd/mm/yyyy a dd/mm/yyyy from any text */
function extractRanges(text){
  text = normalizeInput(text);
  // replace dots in dates (01.02.2000 -> 01/02/2000)
  text = text.replace(/(\d{1,2})\.(\d{1,2})\.(\d{2,4})/g,'$1/$2/$3');
  // find ranges
  const re = /(\d{1,2}\/\d{1,2}\/\d{2,4})\s*(?:a|até|-|–|—|to|ao)\s*(\d{1,2}\/\d{1,2}\/\d{2,4})/gi;
  let m; const out = [];
  while((m = re.exec(text)) !== null){
    const s = normalizeDateStr(m[1]);
    const e = normalizeDateStr(m[2]);
    const ps = parseDMY(s); const pe = parseDMY(e);
    if(ps && pe) out.push({startStr:s,endStr:e,start:ps,end:pe,sAbs:ps.abs,eAbs:pe.abs});
  }
  // fallback: pair sequential dates on same line
  if(out.length === 0){
    const lines = text.split(/\n/);
    for(const line of lines){
      const dates = [...line.matchAll(/(\d{1,2}\/\d{1,2}\/\d{2,4})/g)].map(r=>normalizeDateStr(r[1]));
      for(let i=0;i+1<dates.length;i+=2){
        const s = dates[i], e = dates[i+1];
        const ps = parseDMY(s), pe = parseDMY(e);
        if(ps && pe) out.push({startStr:s,endStr:e,start:ps,end:pe,sAbs:ps.abs,eAbs:pe.abs});
      }
    }
  }
  return out;
}

/* merge contiguous/overlapping intervals (input with numeric sAbs,eAbs) */
function mergeIntervals(arr){
  if(!arr || arr.length===0) return [];
  const conv = arr.map(it=>({s:it.sAbs,e:it.eAbs,startStr:it.startStr,endStr:it.endStr,start:it.start,end:it.end}));
  conv.sort((a,b)=>a.s - b.s || a.e - b.e);
  const res = [];
  let cur = {...conv[0]};
  for(let i=1;i<conv.length;i++){
    const nx = conv[i];
    if(nx.s <= cur.e + 1){
      if(nx.e > cur.e){
        cur.e = nx.e; cur.endStr = nx.endStr; cur.end = nx.end;
      }
    } else {
      res.push({...cur});
      cur = {...nx};
    }
  }
  res.push({...cur});
  // convert back to structured
  return res.map(it=>{
    // reconstruct start/end objects (approx) — we'll keep startStr/endStr for display and s/e for days
    return {startStr:it.startStr,endStr:it.endStr,sAbs:it.s,eAbs:it.e};
  });
}

/* days inclusive with rules required (we use sAbs/eAbs computed from y*365+m*30+d) */
function daysFromAbs(sAbs,eAbs){ return Math.max(0, eAbs - sAbs + 1); }

/* parse money robusto */
function parseMoney(s){
  if(s===undefined||s===null||s==='') return 0;
  s = String(s).trim();
  if(s.indexOf(',')>-1 && s.indexOf('.')>-1) s = s.replace(/\./g,'').replace(',','.');
  else if(s.indexOf(',')>-1) s = s.replace(',','.');
  const v = parseFloat(s);
  return isNaN(v) ? 0 : v;
}

/* extenso simplificado */
function numExtensoRounded(n){
  const v = Math.round(n);
  const units = ["zero","um","dois","três","quatro","cinco","seis","sete","oito","nove","dez","onze","doze","treze","quatorze","quinze","dezesseis","dezessete","dezoito","dezenove","vinte"];
  const dezenas = {30:"trinta",40:"quarenta",50:"cinquenta",60:"sessenta",70:"setenta",80:"oitenta",90:"noventa"};
  if(v<=20) return units[v];
  if(v<100){
    if(v%10===0) return dezenas[v];
    const d = Math.floor(v/10)*10;
    return dezenas[d] + " e " + units[v%10];
  }
  return String(v);
}

/* round to 1 decimal by default (or n) */
function roundTo(n,dec=1){ const f = Math.pow(10,dec); return Math.round(n*f)/f; }

/* ----------------------------
   Lógica principal (cálculos)
   ---------------------------- */

function gatherOptions(){
  return {
    controvertidosText: document.getElementById('inputCont').value,
    acolhidosText: document.getElementById('inputAcol').value,
    houveBeneficio: document.getElementById('selectBenef').value === 'sim',
    houveDanos: document.getElementById('selectDanos').value === 'sim',
    valorCausa: parseMoney(document.getElementById('valorCausa').value || ''),
    valorDanos: parseMoney(document.getElementById('valorDanos').value || ''),
    ajg: document.getElementById('selectAJG').value === 'sim',
    casas: parseInt(document.getElementById('selectCasas').value,10),
    minimoPercent: parseFloat(document.getElementById('minimoInput').value || 10)
  };
}

function computeAndGenerate(opts){
  // extract ranges
  const pairsCont = extractRanges(opts.controvertidosText);
  const pairsAcol = extractRanges(opts.acolhidosText);

  const validCont = pairsCont.filter(it=>it.sAbs <= it.eAbs);
  const validAcol = pairsAcol.filter(it=>it.sAbs <= it.eAbs);

  const mergedCont = mergeIntervals(validCont);
  const mergedAcol = mergeIntervals(validAcol);

  const diasCont = mergedCont.reduce((s,it)=> s + daysFromAbs(it.sAbs,it.eAbs),0);
  const diasAcol = mergedAcol.reduce((s,it)=> s + daysFromAbs(it.sAbs,it.eAbs),0);

  // prop tempo
  const propTempo = diasCont === 0 ? 0 : diasAcol / diasCont;

  // decaimento por danos morais
  let propDecDanos = 0;
  if(opts.houveDanos){
    if(opts.valorCausa > 0){
      propDecDanos = Math.min(1, opts.valorDanos / opts.valorCausa);
    } else {
      propDecDanos = 0;
    }
  }

  // êxito ponderado
  const sucessoP = propTempo * (1 - propDecDanos);
  let decaimentoP = 1 - sucessoP;

  // aplicar regra mínima
  const minimo = opts.minimoPercent / 100;
  let authorShare = sucessoP;
  let defendantShare = decaimentoP;
  let minimaAplicada = null; // "autor" | "inss" | null

  if(authorShare < minimo){
    // autora considerada vencida integralmente
    authorShare = 0;
    defendantShare = 1;
    minimaAplicada = 'autor';
  } else if(defendantShare < minimo){
    defendantShare = 0;
    authorShare = 1;
    minimaAplicada = 'inss';
  }

  // distribuição sobre 10%
  const totalHonorarios = 10; // sempre 10%
  let honorReu = authorShare * totalHonorarios; // réu paga ao autor
  let honorAutor = defendantShare * totalHonorarios; // autor paga ao réu

  // arredondar para uma casa decimal conforme pedido (use opts.casas)
  honorReu = roundTo(honorReu, opts.casas);
  honorAutor = roundTo(honorAutor, opts.casas);

  // preparar minutas (duas variantes)
  const sucessoPct = roundTo(authorShare * 100,1);
  const decaimentoPct = roundTo(defendantShare * 100,1);

  // montar texto conforme houveBeneficio
  let minuta = '';
  if(opts.houveBeneficio){
    // Versão 1 — Concessão de Benefício (Súmula 111 aplicável)
    minuta += `Apurada a proporcionalidade da sucumbência, considerando o êxito da parte autora nos pedidos de reconhecimento de tempo de serviço e a improcedência do pedido de danos morais (se houver), a parte autora obteve êxito ponderado de ${sucessoPct.toFixed(1)}% (${numExtensoRounded(sucessoPct)}) sobre a demanda total.\n\n`;
    minuta += `Em razão da sucumbência recíproca, fixo a verba honorária nos patamares mínimos do art. 85, §3º do CPC, incidentes sobre o valor da condenação, na forma da Súmula 111 do STJ. `;
    // aplicar regra mínima: if minimaAplicada==='autor' => defendantShare=1 => honorReu 0; honorAutor 10
    if(minimaAplicada === 'autor'){
      // autora vencida integralmente -> réu vencedor -> réu não paga honorários a autor; autor paga tudo
      minuta += `Condeno o réu ao pagamento de honorários advocatícios em favor do procurador da parte autora, que fixo em 0,0% do valor das parcelas vencidas. `;
      minuta += `Condeno a parte autora ao pagamento de honorários advocatícios em favor do procurador do réu, que fixo em ${totalHonorarios.toFixed(opts.casas)}% do valor das parcelas vencidas.\n\n`;
    } else if(minimaAplicada === 'inss'){
      // réu vencido integralmente -> author pays 0
      minuta += `Condeno o réu ao pagamento de honorários advocatícios em favor do procurador da parte autora, que fixo em ${totalHonorarios.toFixed(opts.casas)}% do valor das parcelas vencidas. `;
      minuta += `Condeno a parte autora ao pagamento de honorários advocatícios em favor do procurador do réu, que fixo em 0,0% do valor das parcelas vencidas.\n\n`;
    } else {
      minuta += `Condeno o réu ao pagamento de honorários advocatícios em favor do procurador da parte autora, que fixo em ${honorReu.toFixed(opts.casas)}% do valor das parcelas vencidas. `;
      minuta += `Condeno a parte autora ao pagamento de honorários advocatícios em favor do procurador do réu, que fixo em ${honorAutor.toFixed(opts.casas)}% do valor das parcelas vencidas.\n\n`;
    }

    if(opts.ajg){
      minuta += `A exigibilidade dos honorários advocatícios fixados em desfavor da parte autora fica suspensa, nos termos do art. 98, § 3º, do CPC, por ser beneficiária da gratuidade de justiça.\n\n`;
      // exigir ressarcimento das custas ao INSS
      if(minimaAplicada === 'autor'){
        // autora vencida integralmente — INSS é vencedor — no caso de AJG, autor tinha gratuidade, but if she must pay? standard: suspensa but INSS ressarcirá custas? keep consistent with prior drafts:
        minuta += `Condeno o INSS ao ressarcimento proporcional das custas adiantadas pela parte autora.\n\n`;
      } else {
        minuta += `Condeno o INSS ao ressarcimento proporcional das custas adiantadas pela parte autora.\n\n`;
      }
    } else {
      // sem AJG
      if(minimaAplicada === 'autor'){
        minuta += `A parte autora, não beneficiária da gratuidade de justiça, arcará integralmente com a verba honorária acima fixada.\n\n`;
      }
    }

    minuta += `Partes isentas de custas processuais.\n`;
  } else {
    // Versão 2 — Não Concessão do Benefício — sem Súmula 111 aplicada
    const sucessoPct2 = roundTo(authorShare * 100,1);
    minuta += `Apurada a proporcionalidade da sucumbência, considerando o êxito da parte autora nos pedidos de reconhecimento de tempo de serviço e a improcedência do pedido de danos morais (se houver), a parte autora obteve êxito ponderado de ${sucessoPct2.toFixed(1)}% (${numExtensoRounded(sucessoPct2)}), resultando em sucumbência recíproca.\n\n`;
    minuta += `Em razão disso, considerando a proporcionalidade exigida pelos artigos 85, §§ 2º e 3º, e 90, caput, do CPC, condeno as partes ao pagamento de honorários advocatícios recíprocos, fixando-os em 10% (dez por cento) sobre o valor atualizado da causa. `;

    if(minimaAplicada === 'autor'){
      // author loses -> defendant fully wins -> defendant pays 0? Wait mapping: if authorShare 0 => honorReu=0, honorAutor=10
      minuta += `Condeno o réu ao pagamento de honorários advocatícios em favor do procurador da parte autora, que fixo em 0,0% do valor atualizado da causa. `;
      minuta += `Condeno a parte autora ao pagamento de honorários advocatícios em favor do procurador do réu, que fixo em ${totalHonorarios.toFixed(opts.casas)}% do valor atualizado da causa.\n\n`;
    } else if(minimaAplicada === 'inss'){
      minuta += `Condeno o réu ao pagamento de honorários advocatícios em favor do procurador da parte autora, que fixo em ${totalHonorarios.toFixed(opts.casas)}% do valor atualizado da causa. `;
      minuta += `Condeno a parte autora ao pagamento de honorários advocatícios em favor do procurador do réu, que fixo em 0,0% do valor atualizado da causa.\n\n`;
    } else {
      minuta += `Condeno o réu ao pagamento de honorários advocatícios em favor do procurador da parte autora, que fixo em ${honorReu.toFixed(opts.casas)}% do valor atualizado da causa. `;
      minuta += `Condeno a parte autora ao pagamento de honorários advocatícios em favor do procurador do réu, que fixo em ${honorAutor.toFixed(opts.casas)}% do valor atualizado da causa.\n\n`;
    }

    if(opts.ajg){
      minuta += `A exigibilidade dos honorários advocatícios fixados em desfavor da parte autora fica suspensa, nos termos do art. 98, § 3º, do CPC, por ser beneficiária da gratuidade de justiça.\n\n`;
    } else {
      if(minimaAplicada === 'autor'){
        minuta += `A parte autora deverá arcar com a totalidade da verba honorária indicada acima.\n\n`;
      }
    }

    minuta += `Partes isentas de custas processuais.\n`;
  }

  // detalhe numérico para auditoria
  const detalhe = {
    diasCont: diasCont,
    diasAcol: diasAcol,
    propTempo: propTempo,
    propDecDanos: propDecDanos,
    sucessoP_raw: roundTo(sucessoP,3),
    sucessoP_final: roundTo(authorShare,3),
    decaimento_final: roundTo(defendantShare,3),
    honorReuPercent: honorReu,
    honorAutorPercent: honorAutor,
    minimaAplicada: minimaAplicada,
    mergedCont: mergedCont,
    mergedAcol: mergedAcol
  };

  return {minuta, detalhe};
}

/* ============================
   UI Wiring
   ============================ */

const btnProcess = document.getElementById('btnProcess');
const btnCalc = document.getElementById('btnCalc');
const btnCopy = document.getElementById('btnCopy');
const btnDownload = document.getElementById('btnDownload');
const summaryDiv = document.getElementById('summary');
const minutaDiv = document.getElementById('minuta');
const detalheDiv = document.getElementById('detalhe');
const selectDanos = document.getElementById('selectDanos');
const boxDanos = document.getElementById('boxDanos');

selectDanos.addEventListener('change', ()=> {
  boxDanos.style.display = selectDanos.value === 'sim' ? 'block' : 'none';
});

// Processar e mostrar resumo dos períodos
btnProcess.addEventListener('click', ()=> {
  const opts = gatherOptions();
  const pairsCont = extractRanges(opts.controvertidosText);
  const pairsAcol = extractRanges(opts.acolhidosText);
  const validCont = pairsCont.filter(it=>it.sAbs <= it.eAbs);
  const mergedCont = mergeIntervals(validCont);
  const mergedAcol = mergeIntervals(pairsAcol.filter(it=>it.sAbs <= it.eAbs));
  const diasCont = mergedCont.reduce((s,it)=> s + daysFromAbs(it.sAbs,it.eAbs),0);
  const diasAcol = mergedAcol.reduce((s,it)=> s + daysFromAbs(it.sAbs,it.eAbs),0);

  let txt = `Períodos detectados (controvertidos): ${pairsCont.length} (válidos: ${validCont.length})\nPeríodos detectados (acolhidos): ${pairsAcol.length} (válidos: ${pairsAcol.length})\n\nApós mesclagem:\n- Controvertidos (${mergedCont.length}): total ${diasCont} dias\n`;
  txt += mergedCont.map(it=>`  • ${it.startStr} a ${it.endStr}`).join('\n') + '\n\n';
  txt += `- Acolhidos (${mergedAcol.length}): total ${diasAcol} dias\n`;
  if(mergedAcol.length) txt += mergedAcol.map(it=>`  • ${it.startStr} a ${it.endStr}`).join('\n') + '\n\n';
  summaryDiv.innerText = txt;
  minutaDiv.innerText = 'Pronto para cálculo. Clique "Calcular e Gerar Minuta".';
  detalheDiv.innerText = '';
});

// Calcular e gerar minuta
btnCalc.addEventListener('click', ()=> {
  const opts = gatherOptions();
  const result = computeAndGenerate(opts);
  minutaDiv.innerText = result.minuta;
  detalheDiv.innerText = 'Detalhe de cálculo (auditoria):\n' + JSON.stringify(result.detalhe, null, 2);
});

// copiar
btnCopy.addEventListener('click', ()=> {
  const txt = minutaDiv.innerText;
  if(!txt) return alert('Nenhuma minuta para copiar.');
  navigator.clipboard.writeText(txt).then(()=> alert('Minuta copiada para a área de transferência.'));
});

// baixar txt
btnDownload.addEventListener('click', ()=> {
  const txt = minutaDiv.innerText;
  if(!txt) return alert('Nenhuma minuta para baixar.');
  const blob = new Blob([txt],{type:'text/plain;charset=utf-8'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = 'minuta_sucumbencia.txt'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
});

// inicializar campos vazios (evitar pré-preenchimento)
document.getElementById('inputCont').value = '';
document.getElementById('inputAcol').value = '';

</script>
</body>
</html>
